<!DOCTYPE html>
<html>
<head>
    <title>{{ title }}</title>
    <meta http-equiv="content-type" content="text/html" charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

    <link rel="stylesheet" href="/v/jslib/dijit/themes/claro/claro.css">
    <link rel="stylesheet" href="/v/jslib/dojo/resources/dojo.css">
    <link rel="stylesheet" href="/v/jslib/dgrid/css/dgrid.css">
    <link rel="stylesheet" href="/v/jslib/dgrid/css/skins/claro.css">
    <link rel="stylesheet" href="/v/css/app.css">
    <link rel="stylesheet" href="/{{ app_css_dir }}/dijit_btns.css">
    <link rel="stylesheet" href="/{{ app_css_dir }}/dijit_tab_icons.css">
    <link rel="stylesheet" href="/{{ app_css_dir }}/hyper_link.css">
    <script src="/v/js/origin_patch.js"></script>
    <script type="text/javascript"
            src="/v/jslib/My9748/WdatePicker.js">
    </script>
    <script>
        var dojoConfig = {
            parseOnLoad: true, async: true,
            packages: [
                {"name": "shimmy", "location": location.pathname.match(/^\//) + "v/jslib/shimmy"},
                {"name": "roundgis", "location": location.pathname.match(/^\//) + "v/js"},
                {"name": "dgrid", "location": location.pathname.match(/^\//) + "v/jslib/dgrid"},
                {"name": "dstore", "location": location.pathname.match(/^\//) + "v/jslib/dstore"},
                {"name": "rgv", "location": location.pathname.match(/^\//) + "{{ app_js_dir }}"}
            ]
        };
    </script>
    <script>
        //global env here
        var BasicEnv = {
            lang: "{{ user_lang }}",
            curr_location: location.pathname.match(/^\//),
            templatePath: location.pathname.match(/^\//) + "templates",
            rgv_template_path: location.pathname.match(/^\//) + "{{ app_template_dir }}",
            imgpath: location.pathname.match(/^\//) + "v/imgs",
            standby: undefined,
            main_grid: undefined,
            watched_devid: "",
            poll_timer: undefined,
            poll_timer2: undefined
        };
        BasicEnv.sessionid = "{{ sessionid }}";
        BasicEnv.sensor_mins_avg_log_url = "{{ sensor_mins_avg_log_url }}";
        BasicEnv.schedule_view_url = "{{ switch_schedule_view_url }}";
        BasicEnv.set_sensor_trigger_view_url = "{{ set_sensor_trigger_view_url }}";
        BasicEnv.sensor_mins_avg_trend_url = "{{ sensor_mins_avg_trend_url }}";
        BasicEnv.sensor_mins_avg_data_url = "{{ sensor_mins_avg_data_url }}";
        BasicEnv.sensor_recent_hours_plotting_url = "{{ sensor_recent_hours_plotting_url }}";
        BasicEnv.sensorid_for_log_view_cookie = "{{ sensorid_for_log_view }}";
        BasicEnv.cameras_view_url = "{{ cameras_view_url }}";
        BasicEnv.sensor_trend_url = "{{ sensor_trend_url }}";
    </script>

    <script src="/v/jslib/dojo/dojo.js"></script>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        html, body, #main_ui_node {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        .field-watched {
            width: 2em;
        }

        .field-name {
            text-align: center;
        }

        .field-status {
            text-align: center;
        }

        .field-remaining_seconds {
            text-align: center;
        }

        .field-watched1 {
            width: 10%;
        }

        .field-sensor_grid_watched {
            width: 2em;
        }

        .field-sensor_name {
            text-align: center;
        }

        .field-sensor_val {
            text-align: center;
        }
    </style>
</head>
<body class="claro" id="body_node">
<div data-dojo-type="dijit/layout/BorderContainer"
     data-dojo-props="gutters: true, showTitle:false, iconClass: 'dijit_tab_icon_map'"
     id="main_ui_node">
    <div style="width: 16%;"
         data-dojo-type="dijit/layout/ContentPane"
         data-dojo-props="region: 'leading', splitter:true, doLayout:true"
         id="left_ui_node">
        <div id="device_uts_node"></div>
        <div style="padding: 3px 0;"></div>
        <div>
                <a href="_blank" id="sensor_avg_trend_url_node">avg trend</a>
                <span style="display: inline-block; width: 4px; height: 1px;"></span>
                <a href="_blank" id="sensor_avg_data_url_node">data</a>
                <span style="display: inline-block; width: 4px; height: 1px;"></span>
                <a href="_blank" id="sensor_trend_url_node">trend</a>
        </div>
        <div style="padding: 3px 0;"></div>
        <div>
            <select data-dojo-type="dijit/form/Select"
                    id="hours_select_node">
                {% for idx, hours_tbl in enumerate(hours_tbls) %}
                    {% if 'selected' in hours_tbl %}
                        <option value="{{ hours_tbl["value"] }}" selected="selected">{{ hours_tbl["label"] }}</option>
                    {% else %}
                        <option value="{{ hours_tbl["value"] }}">{{ hours_tbl["label"] }}</option>
                    {% end %}
                {% end %}
            </select>
            <span style="width: 3px;" />
            <select data-dojo-type="dijit/form/Select"
                        id="mins_interval_select_node">
                            {% for idx, mins_interval in enumerate(mins_interval_tbls) %}
                                {% if 'selected' in mins_interval %}
                                    <option value="{{ mins_interval["value"] }}" selected="selected">{{ mins_interval["label"] }}</option>
                                {% else %}
                                    <option value="{{ mins_interval["value"] }}">{{ mins_interval["label"] }}</option>
                                {% end %}
                            {% end %}
            </select>
            <button data-dojo-type="dijit/form/Button"
                    id="plot1_btn_node" style="display: none;">plot1
            </button>
            <button data-dojo-type="dijit/form/Button"
                    id="plot2_btn_node">plot2
            </button>
        </div>
        <div style="padding: 3px 0;"></div>
        <div id="sensor_grid_node" style="height: 85%;"></div>
    </div>
    <div data-dojo-type="dijit/layout/BorderContainer" data-dojo-props="region:'center'">
        <div style="height: 35%; width: 100%;"
             data-dojo-type="dijit/layout/ContentPane" data-dojo-props="region:'center'">
            <div style="width: 100%; margin-bottom: 5px;">
                <input data-dojo-type="dijit/form/TextBox"
                       data-dojo-props="trim:true,prpercase:true"
                       id="open_duration_input_node"
                       type="text" style="width: 5em;"/>
                <label>{{ open_duration_label }}</label>
                <button data-dojo-type="dijit/form/Button"
                        id="open_valve_btn_node">{{ open_valve_label }}
                </button>
                <button data-dojo-type="dijit/form/Button"
                        id="close_valve_btn_node">{{ close_valve_label }}
                </button>
                <button data-dojo-type="dijit/form/Button"
                        id="switch_mode_btn_node">{{ switch_mode_label }}
                </button>
                <label id="mode_label_node"></label>
                <button data-dojo-type="dijit/form/Button"
                        id="schedule_btn_node">{{ set_schedule_label }}</button>
                <a href="_blank" id="schedule_view_url_node">{{ switch_schedule_view_label }}</a>
                <a href="_blank" id="set_sensor_trigger_view_url_node">{{ set_sensor_trigger_view_url_label }}</a>
                <a href="_blank" id="cameras_view_url_node">{{ cameras_view_label }}</a>
                <label id="hint_node"></label>
            </div>
            <div id="switch_grid_node" style="height: 80%;"></div>
        </div>
        <div id="plotting_container_node" style="width: 100%; height: 65%;"
             data-dojo-type="dijit/layout/ContentPane"
             data-dojo-props="region:'bottom', splitter:true, doLayout: true">
        </div>
    </div>
    <div style="width: 18%;"
         data-dojo-type="dijit/layout/ContentPane"
         data-dojo-props="region: 'trailing', splitter:true">
        <div data-dojo-type="dijit/Toolbar" style="position: relative;">
            <select id="group_select_node"
                    data-dojo-type="dijit/form/Select" data-dojo-props="maxHeight: -1"></select>
        </div>
        <div style="padding: 5px 0;"></div>
        <div style="position: relative; width:100%; height: 94%;"
             id="main_grid_node">
        </div>
    </div>
</div>
<div id="standby"></div>
</body>
<script>
    require(["dojo/parser", "dojo/_base/declare", "dojo/_base/lang", "dojo/window", "dojo/on", "dojo/aspect", "dojo/query",
                "dojo/dom", "dojo/dom-construct", "dojo/dom-class", "dojo/dom-geometry", "dojo/_base/array", "dojo/dom-style", "dojo/Deferred",
                "dojo/promise/all", "dojo/cookie", "dojo/json",
                "dijit/registry", "dijit/Dialog", "dijit/layout/BorderContainer", "dijit/layout/TabContainer", "dijit/layout/ContentPane",
                "dijit/form/Button", "dijit/Tooltip", "dojox/timing", "dojox/collections/Set",
                "dojox/widget/Standby", "dojox/validate", "dgrid/OnDemandGrid", "dgrid/CellSelection", "dgrid/Editor",
                "dgrid/extensions/ColumnHider", "dgrid/Keyboard",
                "dstore/Memory",
                "roundgis/rtutils", "roundgis/dojo_utils",
                "rgv/em_rpc",
                "rgv/EditSwitchScheduleUI", "rgv/SensorTrendBlockUI",
                "rgv/multi_lang",
                "dojo/ready"],
            function (parser, declare, lang, dwin, on, aspect, query, dom, domc, domclass, dgeom, darray, domstyle,
                      Deferred, all, dcookie, djson, registry,
                      Dialog, BorderContainer, TabContainer, ContentPane, Button, Tooltip,
                      dxtiming, Set, Standby, dx_validate, Grid, Selection, Editor, ColumnHider, Keyboard,
                      Memory,
                      rtutils, dojo_utils,
                      em_rpc, EditSwitchScheduleUI, SensorTrendBlockUI,
                      multi_lang, ready) {
                ready(function () {
                    var InitEnv = function () {
                        BasicEnv.standby = new Standby({target: "main_ui_node"});
                        document.body.appendChild(BasicEnv.standby.domNode);
                        BasicEnv.standby.startup();
                        BasicEnv.main_columns = [
                            {field: "name", label: "Name", unhidable: true}
                        ];
                        BasicEnv.switch_col_tbl = {
                            "eng": [
                                {
                                    label: " ",
                                    field: "watched",
                                    autoSave: true,
                                    unhidable: true,
                                    editor: "checkbox"
                                },
                                {field: "name", label: "Name"},
                                {field: "status", label: "Status"},
                                {field: "remaining_seconds", label: "Remaining"}
                            ],
                            "zho": [
                                {
                                    label: " ",
                                    field: "watched",
                                    autoSave: true,
                                    unhidable: true,
                                    editor: "checkbox"
                                },
                                {field: "name", label: "名字"},
                                {field: "status", label: "状态"},
                                {field: "remaining_seconds", label: "剩余开启时长"}
                            ]
                        };
                        BasicEnv.sensor_col_tbl = {
                            "eng": [
                                {
                                    label: " ",
                                    field: "sensor_grid_watched",
                                    autoSave: true,
                                    unhidable: true,
                                    editor: "checkbox"
                                },
                                {field: "sensor_name", label: "Name"},
                                {field: "sensor_val", label: "Status"}
                            ],
                            "zho": [
                                {
                                    label: " ",
                                    field: "sensor_grid_watched",
                                    autoSave: true,
                                    unhidable: true,
                                    editor: "checkbox"
                                },
                                {field: "sensor_name", label: "名字"},
                                {field: "sensor_val", label: "状态"}
                            ]
                        };
                        BasicEnv.status_tbl = {
                            "ON": {"eng": "on", "zho": "打开"},
                            "OFF": {"eng": "off", "zho": "关闭"},
                            "OFFLINE": {"eng": "offline", "zho": "离线"}
                        };
                        BasicEnv.group_store = new Memory({idProperty: "id"});
                        BasicEnv.serial_dev_store = new Memory({idProperty: "id"});
                        BasicEnv.switch_store = new Memory({idProperty: "id"});
                        BasicEnv.sensor_store = new Memory({idProperty: "id"});
                        BasicEnv.hint_node = dom.byId("hint_node");
                        BasicEnv.open_valve_btn_node = registry.byId("open_valve_btn_node");
                        BasicEnv.close_valve_btn_node = registry.byId("close_valve_btn_node");
                        BasicEnv.switch_btn_node = registry.byId("switch_mode_btn_node");
                        BasicEnv.edit_schedule_ui = new EditSwitchScheduleUI();
                        BasicEnv.edit_schedule_ui.startup();
                        BasicEnv.schedule_btn_node = registry.byId("schedule_btn_node");
                        BasicEnv.dialog = new Dialog();
                        BasicEnv.dialog.startup();
                    };

                    var TranslateUI = function() {
                        dom.byId("sensor_avg_trend_url_node").innerHTML = rtutils.GetLangField(multi_lang.labels["view_trend"], BasicEnv.lang);
                        dom.byId("sensor_avg_data_url_node").innerHTML = rtutils.GetLangField(multi_lang.labels["view_log"], BasicEnv.lang);
                    };

                    var switch2griditem = function(switch_tbl) {
                        return {
                            "watched": false,
                            "id": switch_tbl.id,
                            "name": switch_tbl.name || "",
                            "ownerid": switch_tbl.ownerid,
                            "nid": switch_tbl.nid,
                            "status": switch_tbl.status,
                            "remaining_seconds": switch_tbl.remaining_seconds
                        };
                    };

                    var RGGW2GridItem = function(dev_tbl) {
                        return {
                            "id": dev_tbl.id,
                            "ownerid": dev_tbl.ownerid,
                            "groupid": dev_tbl.groupid,
                            "name": dev_tbl.name || "",
                            "nid": dev_tbl.nid,
                            "loc": dev_tbl.loc,
                            "mode": dev_tbl.mode
                        };
                    };

                    var Sensor2GridItem = function(sensor_tbl) {
                        return {
                            "id": sensor_tbl.id,
                            "ownerid": sensor_tbl.ownerid,
                            "sensor_val": sensor_tbl.val,
                            "sensor_name": sensor_tbl.name,
                            "sensor_no": sensor_tbl.sensor_no,
                            "val_precision": sensor_tbl.val_precision,
                            "val_unit": sensor_tbl.val_unit
                        };
                    };

                    var SyncRGGW = function(groupids) {
                        return rtutils.Rpc2Deferred(em_rpc.GetRGGWByGroup(BasicEnv.sessionid, {"groupids": groupids})).then(
                                function(result) {
                                    for(var i = 0; i!=result.length; ++i) {
                                        BasicEnv.serial_dev_store.putSync(RGGW2GridItem(result[i]));
                                    }
                                },
                                function(err) {
                                    throw err;
                                }
                        );
                    };

                    var SyncSwitch = function (status_only) {
                        //need to remove all valves not binding to these trackers
                        var tempids = BasicEnv.switch_store.filter(function (item) {
                            return item.ownerid !== BasicEnv.watched_devid;
                        }).select("id").fetchSync();
                        if(tempids.length > 0) {
                            for (var i = 0; i != tempids.length; ++i) {
                                BasicEnv.switch_store.removeSync(tempids[i]);
                            }
                            BasicEnv.switch_grid.refresh();
                        }

                        if (BasicEnv.watched_devid) {
                            return rtutils.Rpc2Deferred(em_rpc.FindSwitch(BasicEnv.sessionid, {"gwids": [BasicEnv.watched_devid], "status_only": status_only})).then(
                                    function (result) {
                                        var switches = result.switches;
                                        var devices = result.gws;
                                        if (switches.length > 0) {
                                            for(var i = 0; i!=switches.length; ++i) {
                                                if(status_only) {
                                                    var switch_tbl = BasicEnv.switch_store.getSync(switches[i].id);
                                                    if(switch_tbl) {
                                                        rtutils.Mixin(switch_tbl, switches[i], ["status", "remaining_seconds"]);
                                                    }
                                                }
                                                else {
                                                    BasicEnv.switch_store.putSync(switch2griditem(switches[i]));
                                                }
                                            }
                                            BasicEnv.switch_grid.refresh();
                                        }
                                        if(devices.length > 0) {
                                            var dev_obj = BasicEnv.serial_dev_store.getSync(devices[0].id);
                                            dev_obj.mode = devices[0].mode;
                                            UpdateRGGWMode(devices[0]);
                                        }
                                    },
                                    function (err) {
                                        rtutils.ReloadWhenExpired(err);
                                        console.log(err);
                                    }
                            );
                        }
                        else {
                            var d = new Deferred();
                            setTimeout(function () {
                                d.resolve(false);
                            }, 0);
                            return d.promise;
                        }
                    };

                    var renderMainGridRow = function (row, args) {
                        return row;
                    };

                    var InitMainGrid = function () {
                        BasicEnv.main_grid = new declare([Grid, Selection, ColumnHider, Editor])({
                            columns: BasicEnv.main_columns,
                            selectMode: "single",
                            cellNavigation: true,
                            collection: BasicEnv.serial_dev_store,
                            minRowsPerPage: 2000
                        }, "main_grid_node");
                        BasicEnv.main_grid.startup();
                        aspect.after(BasicEnv.main_grid, "renderRow", function (row, args) {
                            return renderMainGridRow(row, args);
                        });

                        on(BasicEnv.main_grid, "dgrid-select", function (evt) {
                            if (evt.cells[0].column.field == "name") {
                                BasicEnv.watched_devid = evt.cells[0].row.id;
                                SyncSwitch(false);
                                SyncSensorData();
                                BasicEnv.hint_node.innerHTML = "";
                            }
                        });
                    };

                    var RenderValveGridRow = function (row, args) {
                        var SetStatusCell = function (valve, cell_node) {
                            cell_node.innerHTML = rtutils.GetLangField(BasicEnv.status_tbl[valve.status],
                                    BasicEnv.lang);
                        };

                        var SetRemainingSeconds = function(switch_mdl, cell_node) {
                            if(switch_mdl.remaining_seconds > 0) {
                                cell_node.innerHTML = rtutils.seconds2hhmmss(switch_mdl.remaining_seconds);
                            }
                            else {
                                cell_node.innerHTML = "n/a";
                            }
                        };

                        query(".field-status", row).forEach(function (node) {
                            SetStatusCell(args[0], node);
                        });

                        query(".field-remaining_seconds", row).forEach(function(node) {
                            SetRemainingSeconds(args[0], node);
                        });
                        return row;
                    };

                    var InitValveGrid = function () {
                        BasicEnv.switch_grid = new declare([Grid, Selection, Keyboard, Editor])({
                            columns: rtutils.GetLangField(BasicEnv.switch_col_tbl, BasicEnv.lang),
                            selectionMode: "single",
                            cellNavigation: true,
                            collection: BasicEnv.switch_store,
                            minRowsPerPage: 200
                        }, "switch_grid_node");
                        BasicEnv.switch_grid.startup();
                        aspect.after(BasicEnv.switch_grid, "renderRow", function (row, args) {
                            return RenderValveGridRow(row, args);
                        });
                        on(BasicEnv.switch_grid, "dgrid-select", function (evt) {
                            BasicEnv.watched_valveid = evt.cells[0].row.id;
                            if (evt.cells[0].column.field == "id") {
                            }
                            else {
                            }
                        });
                    };

                    var InitSensorGrid = function() {
                        BasicEnv.sensor_grid = new declare([Grid, Selection, Keyboard, Editor])({
                            columns: rtutils.GetLangField(BasicEnv.sensor_col_tbl, BasicEnv.lang),
                            selectionMode: "single",
                            cellNavigation: true,
                            collection: BasicEnv.sensor_store,
                            minRowsPerPage: 200
                        }, "sensor_grid_node");
                        BasicEnv.sensor_grid.startup();
                        aspect.after(BasicEnv.sensor_grid, "renderRow", function (row, args) {
                            return RenderSensorGridRow(row, args);
                        });
                    };

                    var InitMgrs = function () {
                        BasicEnv.poll_timer = new dxtiming.Timer(6*1000);
                        BasicEnv.poll_timer.onTick = function () {
                            SyncSwitch(true);
                        };
                        BasicEnv.poll_timer2 = new dxtiming.Timer(40*1000);
                        BasicEnv.poll_timer2.onTick = function() {
                            SyncSensorData();
                        };
                    };

                    var SyncSensorData = function() {
                        if(BasicEnv.watched_devid) {
                            return rtutils.Rpc2Deferred(em_rpc.FindSensor(BasicEnv.sessionid, {"ownerids": [BasicEnv.watched_devid]})).then(
                                    function (result) {
                                        ShowDeviceData(result);
                                    },
                                    function (err) {
                                        rtutils.ReloadWhenExpired(err);
                                        console.log(err);
                                    }
                            );
                        }
                        else {
                            BasicEnv.sensor_store.setData([]);
                            BasicEnv.sensor_grid.refresh();
                            return dojo_utils.EmptyDeferred();
                        }
                    };

                    var RefreshPlotting1 = function() {
                        var obj = registry.byId("plotting_container_node");
                        var sensorids = BasicEnv.sensor_store.filter({"sensor_grid_watched": true}).select("id").fetchSync();
                        if(sensorids.length > 0) {
                            domc.empty(obj.domNode);
                            rtutils.ShowStandby(BasicEnv.standby);
                            var d_obj = rtutils.Rpc2Deferred(em_rpc.FindSensorMinsAvgLog(BasicEnv.sessionid, {
                                'hours': parseInt(registry.byId("hours_select_node").get("value")),
                                'mins_interval': parseInt(registry.byId("mins_interval_select_node").get("value")),
                                'sensorids': sensorids
                            }));
                            d_obj.then(
                                function(result) {
                                    rtutils.HideStandby(BasicEnv.standby);
                                    var chart_height = 86*1.0/sensorids.length;
                                    for(var i = 0; i!=sensorids.length; ++i) {
                                        var trend_block = new SensorTrendBlockUI({
                                            sensor_mdl: result.sensor_tbl[sensorids[i]],
                                            sensor_data_rows: result.log_tbl[sensorids[i]],
                                            ts_series: result.ts_series
                                        });
                                        trend_block.startup();
                                        obj.addChild(trend_block);
                                        trend_block.SetHeight(chart_height.toFixed(0)+"%");
                                        trend_block.SetWidth("98%");
                                        domc.create("div", {"style": "display: block; padding: 0.6em 0;"}, obj.domNode);
                                        trend_block.Update();
                                    }
                                },

                                function(err) {
                                    rtutils.HideStandby(BasicEnv.standby);
                                    console.log(err);
                                }
                            );

                        }
                    };

                    var RefreshPlotting2 = function() {
                        var obj = registry.byId("plotting_container_node");
                        var box = dgeom.getContentBox(obj.domNode);
                        var sensorids = BasicEnv.sensor_store.filter({"sensor_grid_watched": true}).select("id").fetchSync();
                        if(sensorids.length > 0) {
                            domc.empty(obj.domNode);
                            rtutils.ShowStandby(BasicEnv.standby);
                            var src_url_base = BasicEnv.curr_location+BasicEnv.sensor_recent_hours_plotting_url;
                            var chart_height = box.h*0.9/sensorids.length;
                            for(var i = 0; i!=sensorids.length; ++i) {
                                var src_url = src_url_base + "?width="+box.w*0.95+"&height="+chart_height+"&tz_offset="+rtutils.GetTimezoneOffset();
                                src_url +="&hours="+registry.byId("hours_select_node").get("value");
                                src_url +="&mins="+registry.byId("mins_interval_select_node").get("value");
                                src_url +="&sensorids="+djson.stringify([sensorids[i]]);
                                var embed_obj = domc.create("embed", {"src": src_url}, obj.domNode);
                            }
                            rtutils.HideStandby(BasicEnv.standby);
                        }
                    };

                    var UpdateDeviceUts = function(uts) {
                        dom.byId("device_uts_node").innerHTML = (uts>0)?rtutils.DT2Str(rtutils.ts2date(uts)):"";
                    };

                    var UpdateRGGWMode = function(device_tbl) {
                        dom.byId("mode_label_node").innerHTML = (device_tbl.mode)?device_tbl.mode:"";
                        if(device_tbl.mode == "manual") {
                            BasicEnv.open_valve_btn_node.set("disabled", true);
                            BasicEnv.close_valve_btn_node.set("disabled", true);
                        }
                        else {
                            BasicEnv.open_valve_btn_node.set("disabled", false);
                            BasicEnv.close_valve_btn_node.set("disabled", false);
                        }
                        UpdateDeviceUts(device_tbl.uts);
                    };

                    var ShowDeviceData = function (sensor_data_tbl) {
                        if(sensor_data_tbl.ownerids.length > 0) {
                            for(var i = 0; i!=sensor_data_tbl.ownerids.length; ++i) {
                                var devid = sensor_data_tbl.ownerids[i];
                                var sensors = sensor_data_tbl.data_tbl[devid];
                                SetSensorStore(sensors);
                            }
                        }
                        else {
                            SetSensorStore([]);
                        }
                        BasicEnv.sensor_grid.refresh();
                    };

                    var SetSensorStore = function(sensors) {
                        //need to remove all sensors not binding to these gateway
                        var tempids = BasicEnv.sensor_store.filter(function (item) {
                            return item.ownerid !== BasicEnv.watched_devid;
                        }).select("id").fetchSync();
                        if(tempids.length > 0) {
                            for (var i = 0; i != tempids.length; ++i) {
                                BasicEnv.sensor_store.removeSync(tempids[i]);
                            }
                        }

                        for(var i = 0; i!=sensors.length; ++i) {
                            var temp = BasicEnv.sensor_store.getSync(sensors[i].id);
                            if(temp) {
                                rtutils.Mixin(temp, Sensor2GridItem(sensors[i]),
                                    ["sensor_name", "sensor_val", "val_precision", "val_unit"]);
                            }
                            else {
                                var grid_item = Sensor2GridItem(sensors[i]);
                                grid_item.sensor_grid_watched = false;
                                BasicEnv.sensor_store.putSync(grid_item);
                            }
                        }
                    };

                    var SetSensorGridCellsHelper = function (grid_items) {
                        (function (watchitems) {
                            for (var i = 0; i !== watchitems.length; ++i) {
                                var cell_node = BasicEnv.sensor_grid.cell(watchitems[i].sensorid, "1");
                                if (cell_node.element) {
                                    SetNameCell(watchitems[i], cell_node.element);
                                }
                                else {
                                }
                            }
                        })(grid_items);

                        (function (watchitems) {
                            for (var i = 0; i !== watchitems.length; ++i) {
                                var cell_node = BasicEnv.sensor_grid.cell(watchitems[i].sensorid, "2");
                                if (cell_node.element) {
                                    SetSensorValCell(watchitems[i], cell_node.element);
                                }
                            }

                        })(grid_items);
                    };

                    var RenderSensorGridRow = function (row, args) {
                        query(".field-sensor_name", row).forEach(function (node) {
                            SetNameCell(args[0], node);
                        });
                        query(".field-sensor_val", row).forEach(function (node) {
                            SetSensorValCell(args[0], node);
                        });
                        return row;
                    };

                    var SetNameCell = function (grid_item, cell_node) {
                        cell_node.innerHTML = grid_item.sensor_name;
                    };

                    var SetSensorValCell = function(grid_item, cell_node) {
                        var GetValStr = function() {
                            var precision = rtutils.IsValidNumber(grid_item.val_precision)?grid_item.val_precision:1;
                            return grid_item.sensor_val.val.toFixed(precision);
                        };
                        var DisplayVal = function() {
                            if(lang.isString(grid_item.sensor_val.val)) {
                                cell_node.innerHTML = grid_item.sensor_val.val;
                            }
                            else if(rtutils.IsValidNumber(grid_item.sensor_val.val)) {
                                cell_node.innerHTML = GetValStr()+" "+grid_item.val_unit;
                            }
                            else {
                                cell_node.innerHTML = "N/A";
                            }
                        };
                        if(lang.isObject(grid_item.sensor_val)) {
                            DisplayVal();
                        }
                        else {
                            cell_node.innerHTML = "N/A";
                        }
                    };

                    var GroupInfo2GridItems = function (groups) {
                        for (var i = 0; i != groups.length; ++i) {
                            var grp = groups[i];
                            BasicEnv.group_store.putSync(grp);
                        }
                    };

                    var RefreshApp = function () {
                        BasicEnv.standby.show();
                        rtutils.Rpc2Deferred(em_rpc.GetGroupInfo(BasicEnv.sessionid)).then(
                                function (groups) {
                                    GroupInfo2GridItems(groups);
                                    var grps = BasicEnv.group_store.sort("name", false).fetchSync();
                                    var select_items = darray.map(grps, function (grp) {
                                        return {"label": grp.name, "value": grp.id};
                                    });
                                    select_items.push({"label": "All", "value": "__all", "selected": true});
                                    registry.byId("group_select_node").set("options", select_items);
                                    registry.byId("group_select_node").startup();
                                    return BasicEnv.group_store.select("id").fetchSync();
                                },
                                function (err) {
                                    throw err;
                                }
                        ).then(
                                function(groupids) {
                                    return SyncRGGW(groupids);
                                },
                                function(err) {
                                    throw err;
                                }
                        ).then(
                                function(flag) {
                                    BasicEnv.standby.hide();
                                    BasicEnv.main_grid.refresh();
                                    BasicEnv.poll_timer.start();
                                    BasicEnv.poll_timer2.start();
                                },
                                function(err) {
                                    BasicEnv.standby.hide();
                                    console.log(err);
                                }
                        );
                    };

                    var AfterLogin = function () {
                        InitMainGrid();
                        InitValveGrid();
                        InitSensorGrid();
                        InitMgrs();
                        setTimeout(function () {
                            RefreshApp();
                        }, 1500);
                    };
                    InitEnv();
                    TranslateUI();
                    AfterLogin();

                    on(BasicEnv.open_valve_btn_node, "click", function (evt) {
                        var switchids = BasicEnv.switch_store.filter({"watched": true}).select("id").fetchSync();
                        if (switchids.length > 0) {
                            BasicEnv.hint_node.innerHTML = "";
                            var para = {"switchids": switchids, "working_seconds": -1};
                            var working_secs = registry.byId("open_duration_input_node").get("value");
                            if(!dojox.validate.isInRange(working_secs, {min: 10, max: 9999})) {
                                BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.errs.number_format, BasicEnv.lang);
                                return false;
                            }
                            else {
                                para.working_seconds = parseInt(working_secs);
                            }
                            BasicEnv.standby.show();
                            var defer_obj = rtutils.Rpc2Deferred(em_rpc.OpenRelaySwitch(BasicEnv.sessionid, para));
                            defer_obj.then(
                                    function (result) {
                                        BasicEnv.standby.hide();
                                        if(result.switchids.length > 0) {
                                            var f_obj = new BasicEnv.switch_store.Filter();
                                            var switch_names = BasicEnv.switch_store.filter(f_obj.in('id', result.switchids)).select("name").fetchSync();
                                            BasicEnv.hint_node.innerHTML = switch_names.join(',')+" have conflict schedule";
                                        }
                                        else {
                                            BasicEnv.hint_node.innerHTML = "";
                                        }
                                    },
                                    function (err) {
                                        BasicEnv.standby.hide();
                                        rtutils.ReloadWhenExpired(err);
                                        if(err.declaredType == "NoRight") {
                                            BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.errs.no_right, BasicEnv.lang);
                                        }
                                        else {
                                            BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.errs.server_error, BasicEnv.lang);
                                        }
                                    }
                            );
                        }
                        else {
                            BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.msgs["please_select_relay_switch"], BasicEnv.lang);
                        }
                    });

                    on(BasicEnv.close_valve_btn_node, "click", function (evt) {
                        var switchids = BasicEnv.switch_store.filter({"watched": true}).select("id").fetchSync();
                        if (switchids.length > 0) {
                            BasicEnv.hint_node.innerHTML = "";
                            var para = {"switchids": switchids};
                            BasicEnv.standby.show();
                            var defer_obj = rtutils.Rpc2Deferred(em_rpc.CloseRelaySwitch(BasicEnv.sessionid, para));
                            defer_obj.then(
                                    function (result) {
                                        BasicEnv.standby.hide();
                                        for(var i = 0; i!==result.length; ++i) {
                                            var valve = BasicEnv.switch_store.getSync(result[i].id);
                                            if (valve) {
                                                lang.mixin(valve, result);
                                                BasicEnv.switch_grid.refresh();
                                            }
                                        }
                                    },
                                    function (err) {
                                        BasicEnv.standby.hide();
                                        rtutils.ReloadWhenExpired(err);
                                        if(err.declaredType == "NoRight") {
                                            BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.errs.no_right, BasicEnv.lang);
                                        }
                                        else if(err.declaredType == "Timeout") {
                                            BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.errs.timeout, BasicEnv.lang);
                                        }
                                        else {
                                            BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.errs.server_error, BasicEnv.lang);
                                        }
                                    }
                            );
                        }
                        else {
                            BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.msgs["please_select_relay_switch"], BasicEnv.lang);
                        }
                    });

                    on(BasicEnv.switch_btn_node, "click", function (evt) {
                        if (BasicEnv.watched_devid) {
                            BasicEnv.hint_node.innerHTML = "";
                            var dev_tbl = BasicEnv.serial_dev_store.getSync(BasicEnv.watched_devid);
                            if(dev_tbl.mode == "manual") {
                                var para = {"deviceid": BasicEnv.watched_devid, "mode": "auto"};
                                BasicEnv.standby.show();
                                var defer_obj = rtutils.Rpc2Deferred(em_rpc.SwitchRGGWMode(BasicEnv.sessionid, para));
                                defer_obj.then(
                                        function (result) {
                                            BasicEnv.standby.hide();
                                            return SyncSwitch(true);
                                        },
                                        function (err) {
                                            BasicEnv.standby.hide();
                                            rtutils.ReloadWhenExpired(err);
                                            if(err.declaredType == "NoRight") {
                                                BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.errs.no_right, BasicEnv.lang);
                                            }
                                            else if(err.declaredType == "Timeout") {
                                                BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.errs.timeout, BasicEnv.lang);
                                            }
                                            else {
                                                BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.errs.server_error, BasicEnv.lang);
                                            }
                                        }
                                );
                            }
                        }
                        else {
                            BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.msgs["please_select_serial_device"], BasicEnv.lang);
                        }
                    });

                    on(registry.byId("group_select_node"), "change", function (evt) {
                        BasicEnv.watched_devid = "";
                        if ((evt == "__all")) {
                            BasicEnv.main_grid.set("collection", BasicEnv.serial_dev_store);
                        }
                        else {
                            BasicEnv.main_grid.set("collection", BasicEnv.serial_dev_store.filter({"groupid": evt}));
                        }
                        SyncSensorData();
                        SyncSwitch(false);
                        UpdateDeviceUts(0);
                    });

                    on(BasicEnv.schedule_btn_node, "click", function(evt) {
                        var switchids = BasicEnv.switch_store.filter({"watched": true}).select("id").fetchSync();
                        if(switchids.length > 0) {
                            rtutils.AttachDialog(BasicEnv.dialog, BasicEnv.edit_schedule_ui);
                            BasicEnv.edit_schedule_ui.SetSwitchIds(switchids);
                            BasicEnv.edit_schedule_ui.ResetUI();
                            BasicEnv.dialog.show();
                        }
                        else {
                            BasicEnv.hint_node.innerHTML = rtutils.GetLangField(multi_lang.msgs["please_select_relay_switch"], BasicEnv.lang);
                        }
                    });

                    on(BasicEnv.edit_schedule_ui, "set_schedule", function(evt) {
                        var d_obj = rtutils.Rpc2Deferred(em_rpc.AddSchedule(BasicEnv.sessionid, {"schedule": evt.data}));
                        rtutils.ShowStandby(BasicEnv.standby, BasicEnv.edit_schedule_ui.domNode);
                        d_obj.then(
                                function(result) {
                                    rtutils.HideStandby(BasicEnv.standby, "main_ui_node");
                                    if(result.switchids.length > 0) {
                                        var f_obj = new BasicEnv.switch_store.Filter();
                                        var switch_names = BasicEnv.switch_store.filter(f_obj.in('id', result.switchids)).select("name").fetchSync();
                                        BasicEnv.edit_schedule_ui.SetHint(switch_names.join(',')+" have conflict schedule");
                                    }
                                    else {
                                        BasicEnv.edit_schedule_ui.SetHint("ok");
                                    }
                                },

                                function(err) {
                                    rtutils.HideStandby(BasicEnv.standby, "main_ui_node");
                                    BasicEnv.edit_schedule_ui.SetHint(rtutils.GetLangField(multi_lang.errs["server_error"], BasicEnv.lang))
                                }
                        )
                    });

                    on(dom.byId("schedule_view_url_node"), "click", function(evt) {
                        evt.preventDefault();
                        window.open(BasicEnv.curr_location+BasicEnv.schedule_view_url, BasicEnv.schedule_view_url);
                    });

                    on(dom.byId("set_sensor_trigger_view_url_node"), "click", function(evt) {
                        evt.preventDefault();
                        window.open(BasicEnv.curr_location+BasicEnv.set_sensor_trigger_view_url, BasicEnv.set_sensor_trigger_view_url);
                    });

                    on(dom.byId("cameras_view_url_node"), "click", function(evt) {
                        evt.preventDefault();
                        window.open(BasicEnv.curr_location+BasicEnv.cameras_view_url, BasicEnv.cameras_view_url);
                    });

                    on(dom.byId("sensor_avg_trend_url_node"), "click", lang.hitch(this, function(evt) {
                        evt.preventDefault();
                        var sensorids = BasicEnv.sensor_store.filter({"sensor_grid_watched": true}).select("id").fetchSync();
                        if(sensorids.length > 0) {
                            dcookie(BasicEnv.sensorid_for_log_view_cookie, djson.stringify(sensorids),
                                {path: "/", expires: 1});
                            window.open(BasicEnv.curr_location+BasicEnv.sensor_mins_avg_trend_url,BasicEnv.sensor_mins_avg_trend_url);
                        }
                    }));

                    on(dom.byId("sensor_avg_data_url_node"), "click", lang.hitch(this, function(evt) {
                        evt.preventDefault();
                        var sensorids = BasicEnv.sensor_store.filter({"sensor_grid_watched": true}).select("id").fetchSync();
                        if(sensorids.length > 0) {
                            dcookie(BasicEnv.sensorid_for_log_view_cookie, djson.stringify(sensorids),
                                {path: "/", expires: 1});
                            window.open(BasicEnv.curr_location+BasicEnv.sensor_mins_avg_data_url,BasicEnv.sensor_mins_avg_data_url);
                        }
                    }));

                    on(dom.byId("sensor_trend_url_node"), "click", lang.hitch(this, function(evt) {
                        evt.preventDefault();
                        var sensorids = BasicEnv.sensor_store.filter({"sensor_grid_watched": true}).select("id").fetchSync();
                        if(sensorids.length > 0) {
                            dcookie(BasicEnv.sensorid_for_log_view_cookie, djson.stringify(sensorids),
                                {path: "/", expires: 1});
                            window.open(BasicEnv.curr_location+BasicEnv.sensor_trend_url,BasicEnv.sensor_trend_url);
                        }
                    }));

                    on(registry.byId("plot1_btn_node"), "click", lang.hitch(this, function(evt) {
                        RefreshPlotting1();
                    }));

                    on(registry.byId("plot2_btn_node"), "click", lang.hitch(this, function(evt) {
                        RefreshPlotting2();
                    }));
                });
            });
</script>
</html>